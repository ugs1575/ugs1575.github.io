---
layout: default
title: TIL_230418
parent: JPA OPTIMIZE
last_modified_at: "23.04.18"
---

# TIL_230418
{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

# OSIV와 성능 최적화

## Controller 에서 repository 바로 접근
```java
@GetMapping("/api/v1/orders")
public List<Order> ordersV1() {
	List<Order> all = orderRepository.findAllByString(new OrderSearch());

	for (Order order : all) {
		order.getMember().getName();
		order.getDelivery().getAddress();

		List<OrderItem> orderItems = order.getOrderItems();
		orderItems.forEach(o -> o.getItem().getName());
	}

	return all;
}
```

- 위 코드를 보면 트랜잭션이 없는 상태에서 어떻게 지연로딩 초기화가 가능할까?
- 일단 첫번째로 컨트롤러에서 직접 리포지토리를 참조하는 경우 두가지 방법이 있다.
- 읽기 전용 트랜잭션 트랜잭션 사용
	- 리포지토리 조회 기능에 명시적으로 읽기 트랜잭션을 적용 (@Transactional(readOnly = true))
- 트랜잭션 밖에서 읽기
	- 리포지 토리 조회 기능에 트랜잭션을 명시 안함
	- 이럴경우 트랜잭션이 시작하지 않고 단순히 커넥션을 획득해서 DB에서 바로 쿼리로 요청한다. 그리고 영속성 컨텍스트에 등록된다. JPA에서 데이터를 변경할 때는 트랜잭션이 필수지만 읽기만 할 때는 트랜잭션이 없어도 동작한다. 
	- 트랜잭션 범위가 없는 상태라 수정은 불가능하지만 조회는 가능하고 영속상태를 유지할 수 있다.
- 더불어 위 코드가 작동하는 이유는 OSIV가 기본적으로 true로 적용되어 있어 영속성 컨텍스트 생존범위가 트랜잭션 범위 밖인 Controller, View, Filter & Interceptor 까지 이기 때문이다.





- Open Session In View: 하이버네이트 
- Open EntityManager In View: JPA

jpa에서 entitymanager가 하이버네이트에서 session인거

이걸 모르면 장애로 이어질 수 있음

언제 jpa 데이터베이스 커넥션을 가져오고 언제 데이터베이스 커넥션을 반환할까

영속성 컨텍스트를 사용하려면 내부적으로 데이터베이스 커넥션을 가져와야 한다.
트랙잭션을 시작할 때 영속성 컨텍스트가 데이터 베이스 커넥션을 가져온다.

서비스 계층 트랜잯션 시작할 때 

오픈세션인뷰가 켜져있으면 서비스 계층에서 트랜잭션이 끝나서
컨트롤러 까지 나가도 커넥션을 반환을 안한다.

컨트롤러 에서도 lazy 로딩 가능

반환한 순간 영속성 컨텍스트 안씀

어떻게 해결 해야할까
트랜잭션 안에서 로딩 하거나 페치 조인을 사용해야함



## Ref.
- <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94/dashboard">김영한님의 JPA 강의</a>
