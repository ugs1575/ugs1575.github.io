---
layout: default
title: TIL_220922
parent: Spring
last_modified_at: "22.09.22"
---

# TIL_220922
{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

## 좋은 객체 지향 프로그램이란?
- 유연하고 변경에 용이해진다.
- 다형성
  - 역할과 구현으로 구분
  - 운전자 역할과 자동차 역할이 있다.
  - k3탔다가 아반떼 탄다고 해서 자동차의 역할과 운전자의 역할이 바뀌지 않는다.
  - 운전자 때문에 이렇게 한 것. 운전자(클라이언트)는 내부 구조를 몰라도 된다. 운전자는 자동차를 변경해도 그대로 운전할 수 있다. <span class="bg-green-100">운전자를 바꿀 필요가 없다.</span>
  - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
  - 클라이언트는 내부 구조를 몰라도 된다.
  - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
  - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
  - 자바 언어의 다형성 오버라이딩으로 활용
  - 역할과 구현을 분리하게 되면 확장 가능한 설계가 가능하다
  - 역할 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 발생한다.
  - <span class="bg-green-100">인터페이스를 안정적으로 잘 설계하는 것(변화를 최소화 하는 것)이 가장중요하다.</span>

## 스프링과 객체 지향
- 객체 지향의 꽃은 다형성이다. 
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- IoC, DI는 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리

1. SRP 단일 책임 원칙 (Single Responsibility principle)
- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 클수도 있고 작을 수도 있고 실무에서는 사실 모호하다.
- 그렇다면 어떤것이 설계가 잘 됐다고 볼 수 있을까? 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
- 예를들어 UI를 변경하면 나머지 코드를 다고쳐야한다. -> 잘 못 된것, 계층을 분리해야함.
- 적절하게 범위를 정해야함, 범위를 크게하면 너무 책임이 많고 작게하면 너무 적다

2. OCP 개방-폐쇄 원칙 (Open/Closed principle)
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야한다.
- 다형성을 활용해보자. 
- 다음코드에는 문제가 있다.
```java
MemberRepository m = new MemoryMemberRepository(); //기존코드
MemberRepository m = new JdbcMemberRepository(); //변경코드
```
- MemberService 클라이언트가 구현 클래스를 직접 선택하고 있다.
- 구현 객체를 변경하려면 클라이언트 코드를 변경해야한다. => OCP 원칙이 깨진다.
- 이 문제를 해결하려면 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요한다. => 스프링 컨테이너

3. LSP 리스코프 치환 원칙 (Liskov substitution principle)
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것
- 예) 자동차 인터페이스의 엑셀은 앞으로 가도록 기능을 만들었는데 뒤로 가게 구현하면 LSP 위반이다.

4. ISP 인터페이스 분리 원칙 (Interface segregation principle)
- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스를 운전 인터페이스와 정비 인터페이스로 분리하면
- 사용자 클라이언트를 운전자 클라이언트, 정비사 클라이언트로 분리할 수 있다.
- 작게 분리하면 변경에 의해 서로 영향을 주지 않는다. ( 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음)
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.


5. DIP 의존관계 역전 원칙 (Dependency inversion principle)
- 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
- 예) 원빈은 김태희와 연극 준비를 같이 했는데, 여배우가 다른 배우로 바뀐다고 해서 연극을 못하면 안된다.
```java
MemberRepository m = new MemoryMemberRepository(); //기존코드
MemberRepository m = new JdbcMemberRepository(); //변경코드
```
- DIP 위반
- MemberService는 MemberRepository에도 의존하지만, 구현 클래스인 MemoryMemberRepository에도 의존한다.

- 가장 중요한 원칙이 OCP, DIP이다.
- 객체지향의 핵심은 다형성이다.
- 하지만 다형성 만으로는 OCP, DIP를 지킬 수 없다.
- 순수하게 자바로 OCP, DIP 원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게 된다. (더 정확히는 DI 컨테이너)

## 정리
- 모든 설계에 역할과 구현을 분리하자.
- 이상적으로는 모든 설계에 인터페이스를 부여하자.
- 예) 할인 개발을 해야하는데 아직 정책이 안정해졌다. => 간단한 인터페이스 만들어놓고 시작, 0원 할인
- 실무에서는
  - 인터페이스를 도입하면 추상화라는 비용이 발생한다.
  - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링해서 인터페이스를 도압하는 것도 방법이다.
- 개발자 코드를 한번더 열어봐야함 런타임에 구현체가 결정되니까

## Ref.
- <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard">김영한님의 스프링 강의</a>
