---
layout: default
title: BOJ 10799_쇠막대기
parent: Algorithms
last_modified_at: "22.08.22"
---

# [백준] 10799번 쇠막대기
{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

---
## 문제
여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다.

- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.
- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.
- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다. 
아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.
<p align="center"><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10799/1.png"></p>


이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.

레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반드시 레이저를 표현한다.
쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다. 
위 예의 괄호 표현은 그림 위에 주어져 있다.

쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다. 

쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오.

- 문제링크 :
<a href="https://www.acmicpc.net/problem/10799">https://www.acmicpc.net/problem/10799
</a>

---
## 입력
한 줄에 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다. 

---
## 출력
잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다.

---
## 예제 입력 1

```
입력
()(((()())(())()))(())

출력
17
```

## 예제 입력 2
```
입력
(((()(()()))(())()))(()())

출력
24
```
---
## 접근 방식
정답률이 높은 문제였는데, 매번 오랜만에 시도할 때마다 풀지 못했다.
고민하다가 생각한 방식 다음과 같다.
1. 레이저인 괄호의 인덱스를 저장해놓고
2. 입력 문자를 한 글자씩 돌면서
    - 만약, 레이저 인덱스이면 건너뛴다.
    - 여는 괄호이면 해당 인덱스를 스택에 넣는다.
    - 닫는 괄호이면 스택에서 pop 한다. pop 한 값이 여는 괄호이면 저장한 레이저 인덱스를 돌면서 여는 괄호와 닫는 괄호의 인덱스에 속한 레이저 총 수를 찾는다.
찾은 총개수에 +1을 하여 반환할 변수에 더한다.

이 접근 방식이 시간 초과가 날 걸 알면서도 풀었지만 역시나 시간 초과

---
## 풀이 방식
풀이 방식을 보니 입력 문자를 한 글자씩 돌면서 
1. 여는 괄호이면 stack에 인덱스를 push
2. 닫는 괄호이면 stack에 pop 한 값과 인덱스가 1차이가 난다면 => 레이저다
그때 여는 괄호의 수를 세어주면 된다. 즉, 반환 변수에 스택 사이즈를 더해준다.
3. 닫는 괄호이면서 stack에 pop 한 값과 인덱스가 1차이가 나지 않는다면
+1을 해준다.

결론: 하나의 쇠막대기가 끝나는 지점까지 여는 괄호를 구하면 해당 막대를 통과하는 레이저의 수를 구할 수 있고, 쇠막대기 조각의 총개수는 지나간 레이저의 수 +1이다. 그러니 쇠막대기가 끝나는 시점에서 +1을 해준다. 

---
## 코드
```java
import java.util.*;
public class Main{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String input = sc.next();
        int n = input.length();
        int i = 0;
        int stick = 0;

        Stack<Integer> stack = new Stack<Integer>();
        while (i < n){
            if(input.charAt(i) == '('){
                stack.push(i);
            }else{
                //레이저
                if(i-stack.pop()==1){
                    stick+=stack.size();
                    //쇠막대기
                }else{
                    stick++;
                }
            }
            i++;
        }

        System.out.print(stick);

    }
}
```