---
layout: default
title: TIL_230308
parent: JPA BASIC
last_modified_at: "23.03.08"
---

# TIL_230308
{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

## 다양한 연관관계 매핑

### 다대일 @ManyToOne

- Member : Team (N:1), 주인은 member
- 양방향 관계 설정 예제 코드

```java
class Member {
	@ManyToOne
	@JoinColumn(name = "TEAM_ID")
	private Team team;
}

class Team {
	@OneToMany(mappedBy = "team")
	private List<Member> members = new ArrayList<>();
}
```

- 주인의 반대편은 외래 키에 영향을 주지 않음, 단순 조회만 가능
- 따라서 team.getMembers()로 조회만 가능하고, members에 변화를 주지는 못한다.
- members는 list 타입으로 new ArrayList<>() 초기화를 시켜줘야한다.

### 일대다 @OneToMany
- 일대다 단방향은 일이 연관관계의 주인으로 일이 외래키를 관리한다.

```java
class Team {
	@OneToMany
	@JoinColumn(name = "TEAM_ID")
	private List<Member> members = new ArrayList<>();
}
```

- member의 team을 업데이트를 한다면 다음 코드가 될 것이다.

```java
Member member = new Member();
member.setUsername("member1");

em.persist(member);

Team team = new Team();
team.setName("teamA");
team.getMembers().add(member);

em.persist(team);
```

- 이렇게되면 insert 쿼리 2번 member의 team id를 update 해주는 쿼리가 한번 더 나간다.
- 왜냐하면 외래키를 member가 아닌 team이 관리하기 때문이다.
- 결론 : 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자
- @JoinColumn을 사용하지 않으면 중간 pivot 테이블이 생겨버린다.
- 참고
	- @JoinColumn(insertable=false, updatable=false)
	- 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
	- 이런 매핑은 공식적으로 존재하지 않는다.

### 일대일 @OneToOne
### 다대다 @ManyToMany

## Ref.
- <a href="https://www.inflearn.com/course/ORM-JPA-Basic/dashboard">김영한님의 JPA 강의</a>
